Permissions
-----------

edit database (no reason to split add/change/delete)
add users
export data
change permissions

This maybe doesn't make sense: we could allow all logged in users to edit the
database, and allow superusers to do the admin tasks. But maybe it makes sense
to distinguish registered downloaders from people empowered to edit the
database.

Groups: 

* Administrator (Everything)
* Contributor (Everything with data, but not user admin)
* Registered User (downloading and commenting)
* Anonymous (Viewing)

Each group gets the cumulative permissions of the other groups

It would be nice to distinguish "released" and "unreleased" data too...

Design
------

* Buttons. Disabling a button once is has been pressed::

    <input type="submit" value="Submit" onclick="this.disabled=true" />

* other usability hints, e.g. shadows of active boxes::

    http://www.smashingmagazine.com/2009/01/12/10-useful-web-application-interface-techniques/

  - think also about ``input:focus``::

      input {
        border: 2px solid #888;
        padding: 4px;
        font-size: 1em;
        background-color: #F8F8F8;
      }

      input:focus {
        border-color: #000;
        background-color: #FFFE9D;
      }


Reversion
---------

when registering models with the Reversion low level API, you can tell it to
follow foreign keys, either directly::

  reversion.register(CognateJudgement, follow=["lexeme", "cognate_class"])

or backwards::

  reversion.register(Lexeme, follow=["cognate_judgement_set"])

This only makes sense in cases where two models are always changed at once. It
looks like this might not be necessary.

Rather than listing all revisions, list all objects that have changes, with the
number of versions for each, and click to see object history.

Handy for viewing fields: Models include a list of fields, which you can get to
via the ``_meta`` attribute, e.g.::

  [f.name for f in Lexeme._meta.fields]

More info at http://www.b-list.org/weblog/2007/nov/04/working-models/


Commenting
----------

Julia's suggestions
-------------------

1)  It might be a good idea to allow direct links between different meaning
    since there are cases where I referred to related meanings/forms (e.g.
    with the Toch. terms for BIRD which are simply the equivalent of flying
    ANIMAL)

2)  Another handy application could be a search function (just in order to
    locate terms once seen or the like).

3)  I came across a couple of terms (across different meanings) which are
    ultimately cognate, for instance there is a common IE root dheu- in many
    terms for DUST, SMOKE, BLOW and BREATHE. Consequently, these terms would
    belong to one single CC, wouldn't they? I don't how you want to deal with
    this, but I expect this phenomenon to come up time and again as the work
    will proceed.

Notes: search function will be hard―it's not really clear how to deal with
unicode text entry beyond just using grep with re.UNICODE option and leaving
the rest of the problem to the user. Maybe 'grep' and 'glob' options, and check
boxes for which fields to search.

Items (1) and (3) are probably the same issue. The architecture allows a
CognateSet object to link to forms in more than one meaning set. The link to
the meaning list is only about display―analysis is done on the basis of cognate
sets, which don't pay any attention to the meaning table.

* There needs to be a sensible input method. Maybe allow a view to display two
  or more different meaning sets, e.g. /meaning/dust+blow+smoke/?

* Maybe add a button to show overlapping cognates registered with different
  meaning sets? This would mean that the MEANING display would show all cognate
  sets including at least one form registered as belonging to that meaning.

TECHNICAL NOTES
===============

``Model.get_absolute_url()`` is the django native way of doing my
``Model.canonical_url()`` ― refactor everything to use this instead (the admin
site will love me for it).  Further:

  It's good practice to use get_absolute_url() in templates, instead of
  hard-coding your objects' URLs. For example, this template code is bad::

    <a href="/people/{{ object.id }}/">{{ object.name }}</a>

  But this template code is good::

    <a href="{{ object.get_absolute_url }}">{{ object.name }}</a>

Everything that might be linked to **must** have a get_absolute_url method. On
the recent changes page it would be useful to have links to everything (from
the other pages it's more limited).
  
Tagging
-------

The generic relation/generic foreign key functions in the ContentTypes app
(used e.g. for implementing tagging) could be used to track what users have
done.

But see also http://code.google.com/p/django-tagging/

Selecting languages by cognate class
------------------------------------

The following query gets a list of language ids which have a reflex of cognate
set five::

  CognateSet.objects.get(id=5).lexeme_set.values_list("language", flat=True)

To get this to respect cognate judgement reliability::

  CognateSet.objects.get(id=5).cognatejudgement_set.filter(
    cognatejudgementcitation__reliability="A").values_list(
    "lexeme__language", flat=True)

Joins
-----

To go backwards through ``ManyToMany`` and ``ForeignKey`` fields the attribute
name is generated by appending ``_set`` to the lower case model name. Note that
this means that cognate_set is a horrible choice for a field name.

Big joins across tables::

  In [2]: c = CognateSet.objects.get(id=1)

  In [12]: c.cognatejudgement_set.all()[0].lexeme.meaning
  Out[12]: <Meaning: AND>

Another trick uses the double-underscore syntax::

  Lexeme.objects.filter(meaning__gloss="blood")

There's a way you can inspect the raw sql in DEBUG mode: what is it?

QuerySet objects
----------------

- can be concatenated with a "|"::

    cs = CognateSet.objects.filter(alias="O") | CognateSet.objects.filter(alias="P")

  But this only works if it can be parsed as an instance of sql AND

  Another way to express this, using Q-objects::

    cs = CognateSet.objects.filter(Q(alias="O") | Q(alias="P"))

Database trigger
----------------

http://docs.djangoproject.com/en/dev/topics/signals/#topics-signals

Django equivalent of a database trigger::

  from django.db.models import signals

  def update_bookmark_aggregate(sender, instance, **kwargs):
      bmark = instance.bookmark
      bmark.num_votes = bmark.votes.count()
      bmark.score = sum(bmark.votes.values_list('value', flat=True))
      bmark.save(force_update=True)
  signals.post_save.connect(update_bookmark_aggregate, sender=Vote)

From: http://www.eflorenzano.com/blog/post/database-triggers-arent-evil-and-they-actually-kin/

Alternate rendering method
--------------------------

Which I haven't made work::

  from django.shortcuts import render_to_response

  def render_to(template_name):
      """Rendering decorator
      Usage:

        @render_to('my_template.html')
        def my_view(request):
            # View code here...
            return some_dict
      """
      def renderer(func):
          def wrapper(request, *args, **kw):
              output = func(request, *args, **kw)
              if not isinstance(output, dict):
                  return output
              return render_to_response(request, template_name, output)
          return wrapper
      return renderer

Database Backups
----------------

Very good level of compression:

 ===================  =========  ===========
 original file          2360320  db.sqlite3
 text dump              3402426  db.dump
 bzip2ed dump            329966  db.dump.bz2
 reconstitiuted file    2350080  tmp.sqlite3
 ===================  =========  ===========

A useful commandline is::

  sqlite3 db.sqlite3 .dump | bzip2 > db.dump.bz2

vim
---

When lots of tabs open, shorted the labels with::

  set guitablabel=%t

Icons
-----

Acknowledge that I'm using the Sweetie BasePack ::

   Author:  Joseph North
   Email:   sublick@gmail.com
   Licence: Attribution-ShareAlike 3.0
   Website: sweetie.sublink.ca

.. vim:ft=rst
