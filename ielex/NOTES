DESIGN
======


Julia's suggestions
-------------------

1)  It might be a good idea to allow direct links between different meaning
    since there are cases where I referred to related meanings/forms (e.g.
    with the Toch. terms for BIRD which are simply the equivalent of flying
    ANIMAL)

2)  Another handy application could be a search function (just in order to
    locate terms once seen or the the like).

3)  I came across a couple of terms (across different meanings) which are
    ultimately cognate, for instance there is a common IE root dheu- in many
    terms for DUST, SMOKE, BLOW and BREATHE. Consequently, these terms would
    belong to one single CC, wouldn"t they? I don't how you want to deal with
    this, but I expect this phenomenon to come up time and again as the work
    will proceed.

Notes: search function will be hardâ€•it's not really clear how to deal with
unicode text entry beyond just using grep with re.UNICODE option and leaving
the rest of the problem to the user. Maybe 'grep' and 'glob' options, and check
boxes for which fields to search.

Items (1) and (3) are probably the same issue. The architecture allows a
CognateSet object to link to forms in more than one meaning set. But there just
needs to be a sensible input method. Maybe allow a view to display two or more
different meanign sets, e.g. /meaning/dust+blow+smoke/

TECHNICAL NOTES
===============

Debugging
---------

Add ``assert False`` in your view code to dump debug information.

Selecting languages by cognate class
------------------------------------

The following query gets a list of language ids which have a reflex of cognate
set five::

  CognateSet.objects.get(id=5).lexeme_set.values_list("language", flat=True)

To get this to respect cognate judgement reliability::

  CognateSet.objects.get(id=5).cognatejudgement_set.filter(
    cognatejudgementcitation__reliability="A").values_list(
    "lexeme__language", flat=True)

Joins
-----

To go backwards through ``ManyToMany`` and ``ForeignKey`` fields the attribute
name is generated by appending ``_set`` to the lower case model name. Note that
this means that cognate_set is a horrible choice for a field name.

Big joins across tables::

  In [2]: c = CognateSet.objects.get(id=1)

  In [12]: c.cognatejudgement_set.all()[0].lexeme.meaning
  Out[12]: <Meaning: AND>

Another trick uses the double-underscore syntax::

  Lexeme.objects.filter(meaning__gloss="blood")


QuerySet objects
----------------

- can be concatenated with a "|"::

  cs = CognateSet.objects.filter(alias="O") | CognateSet.objects.filter(alias="P")

Database trigger
----------------

http://docs.djangoproject.com/en/dev/topics/signals/#topics-signals

Django equivalent of a database trigger::

  from django.db.models import signals

  def update_bookmark_aggregate(sender, instance, **kwargs):
      bmark = instance.bookmark
      bmark.num_votes = bmark.votes.count()
      bmark.score = sum(bmark.votes.values_list('value', flat=True))
      bmark.save(force_update=True)
  signals.post_save.connect(update_bookmark_aggregate, sender=Vote)

From: http://www.eflorenzano.com/blog/post/database-triggers-arent-evil-and-they-actually-kin/

Forms
-----

Making your own form via a template:

http://code.djangoproject.com/wiki/TemplatedForm

This article shows how to use template to render CustomForms instead of
as_p(), as_table()...

To make the snippet work, change:

 * from ``django import newforms as forms`` to ``from django import forms``
 * from ``django.newforms.forms import BoundField`` to ``from
   django.forms.forms import BoundField``

This looks like the way to get my own classes into forms for css, e.g.
th.colheader { text-align: center }; th.rowheader { text-align: right }.


Bar charts
----------

can be made with templates::

 <img src="bar.gif" height="10" width="{% widthratio this_value max_value 100 %}" />
 
I'm not quite sure what the widthratio tag is useful for, since surely a
constant width bar is all you need.

Database Backups
----------------

Very good level of compression:

 ===================  =========  ===========
 original file          2360320  db.sqlite3
 text dump              3402426  db.dump
 bzip2ed dump            329966  db.dump.bz2
 reconstitiuted file    2350080  tmp.sqlite3
 ===================  =========  ===========

A useful commandline is::

  sqlite3 db.sqlite3 .dump | bzip2 > db.dump.bz2

login pages
-----------

Don't write your own: take them from the auth/admin modules

http://stackoverflow.com/questions/550632/favorite-django-tips-features/559972#559972

vim
---

When lots of tabs open::

  set guitablabel=%t

Icons
-----

I'm using Sweetie BasePack ::

   Author:  Joseph North
   Email:   sublick@gmail.com
   Licence: Attribution-ShareAlike 3.0
   Website: sweetie.sublink.ca

.. vim:ft=rst
