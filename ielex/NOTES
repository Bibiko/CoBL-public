DESIGN
======

Reversion
---------

when registering models with the Reversion low level API, you can tell it to
follow foriegn keys, either directly::

  reversion.register(CognateJudgement, follow=["lexeme", "cognate_class"])

or backwards::

  reversion.register(Lexeme, follow=["cognate_judgement_set"])

This only makes sense in cases where two models are always changed at once. It
looks like this might not be necessary.

Rather than listing all revisions, list all objects that have changes, with the
numver of versions for each, and click to see object history.

Models include a list of fields, which you can get to via the ``_meta``
attribute, e.g.::

  [f.name for f in Lexeme._meta.fields]


Permissions
-----------

edit database (no reason to split add/change/delete)
add users
export data
change permissions

This maybe doesn't make sense: we could allow all logged in users to edit the
database, and allow superusers to do the admin tasks. But maybe it makes sense
to distinguish registered downloaders from people empowered to edit the
database.

Groups: 

Administrator
Contributor
Registered User (downloader/commenter)

Each group gets the cumulative permissions of the other groups

Julia's suggestions
-------------------

1)  It might be a good idea to allow direct links between different meaning
    since there are cases where I referred to related meanings/forms (e.g.
    with the Toch. terms for BIRD which are simply the equivalent of flying
    ANIMAL)

2)  Another handy application could be a search function (just in order to
    locate terms once seen or the the like).

3)  I came across a couple of terms (across different meanings) which are
    ultimately cognate, for instance there is a common IE root dheu- in many
    terms for DUST, SMOKE, BLOW and BREATHE. Consequently, these terms would
    belong to one single CC, wouldn"t they? I don't how you want to deal with
    this, but I expect this phenomenon to come up time and again as the work
    will proceed.

Notes: search function will be hardâ€•it's not really clear how to deal with
unicode text entry beyond just using grep with re.UNICODE option and leaving
the rest of the problem to the user. Maybe 'grep' and 'glob' options, and check
boxes for which fields to search.

Items (1) and (3) are probably the same issue. The architecture allows a
CognateSet object to link to forms in more than one meaning set. But there just
needs to be a sensible input method. Maybe allow a view to display two or more
different meaning sets, e.g. /meaning/dust+blow+smoke/

TECHNICAL NOTES
===============

``Model.get_absolute_url()`` is the django native way of doing my
``Model.canonical_url()``

For further refactoring:

  It's good practice to use get_absolute_url() in templates, instead of
  hard-coding your objects' URLs. For example, this template code is bad::

    <a href="/people/{{ object.id }}/">{{ object.name }}</a>

  But this template code is good::

    <a href="{{ object.get_absolute_url }}">{{ object.name }}</a>

  
Tagging
-------

The generic relation/generic foreign key functions in the ContentTypes app
(used e.g. for implementing tagging) could be used to track what users have
done.


Debugging
---------

Add ``assert False`` in your view code to dump debug information.

Selecting languages by cognate class
------------------------------------

The following query gets a list of language ids which have a reflex of cognate
set five::

  CognateSet.objects.get(id=5).lexeme_set.values_list("language", flat=True)

To get this to respect cognate judgement reliability::

  CognateSet.objects.get(id=5).cognatejudgement_set.filter(
    cognatejudgementcitation__reliability="A").values_list(
    "lexeme__language", flat=True)

Joins
-----

To go backwards through ``ManyToMany`` and ``ForeignKey`` fields the attribute
name is generated by appending ``_set`` to the lower case model name. Note that
this means that cognate_set is a horrible choice for a field name.

Big joins across tables::

  In [2]: c = CognateSet.objects.get(id=1)

  In [12]: c.cognatejudgement_set.all()[0].lexeme.meaning
  Out[12]: <Meaning: AND>

Another trick uses the double-underscore syntax::

  Lexeme.objects.filter(meaning__gloss="blood")


QuerySet objects
----------------

- can be concatenated with a "|"::

  cs = CognateSet.objects.filter(alias="O") | CognateSet.objects.filter(alias="P")

Database trigger
----------------

http://docs.djangoproject.com/en/dev/topics/signals/#topics-signals

Django equivalent of a database trigger::

  from django.db.models import signals

  def update_bookmark_aggregate(sender, instance, **kwargs):
      bmark = instance.bookmark
      bmark.num_votes = bmark.votes.count()
      bmark.score = sum(bmark.votes.values_list('value', flat=True))
      bmark.save(force_update=True)
  signals.post_save.connect(update_bookmark_aggregate, sender=Vote)

From: http://www.eflorenzano.com/blog/post/database-triggers-arent-evil-and-they-actually-kin/

Forms
-----

Making your own form via a template:

http://code.djangoproject.com/wiki/TemplatedForm

This article shows how to use template to render CustomForms instead of
as_p(), as_table()...

To make the snippet work, change:

 * from ``django import newforms as forms`` to ``from django import forms``
 * from ``django.newforms.forms import BoundField`` to ``from
   django.forms.forms import BoundField``

This looks like the way to get my own classes into forms for css, e.g.
th.colheader { text-align: center }; th.rowheader { text-align: right }.


Bar charts
----------

can be made with templates::

 <img src="bar.gif" height="10" width="{% widthratio this_value max_value 100 %}" />
 
I'm not quite sure what the widthratio tag is useful for, since surely a
constant width bar is all you need.

Database Backups
----------------

Very good level of compression:

 ===================  =========  ===========
 original file          2360320  db.sqlite3
 text dump              3402426  db.dump
 bzip2ed dump            329966  db.dump.bz2
 reconstitiuted file    2350080  tmp.sqlite3
 ===================  =========  ===========

A useful commandline is::

  sqlite3 db.sqlite3 .dump | bzip2 > db.dump.bz2

login
-----

Don't write your own: take them from the auth/admin modules

http://stackoverflow.com/questions/550632/favorite-django-tips-features/559972#559972

- the login_required decorator can be applied in the urls.py file, e.g.::

  from django.contrib.auth.decorators import login_required
  (r'^the_url/', myapp.views.function),
  (r'^the_url/edit/', login_required(myapp.views.function), {"edit":True}),

vim
---

When lots of tabs open, shorted the labels with::

  set guitablabel=%t

Icons
-----

Acknowledge that I'm using the Sweetie BasePack ::

   Author:  Joseph North
   Email:   sublick@gmail.com
   Licence: Attribution-ShareAlike 3.0
   Website: sweetie.sublink.ca

.. vim:ft=rst
