DESIGN
======

Database function
-----------------

- Click on the ``source form`` field in the language and word views to get
  source information (maybe as some kind of popup?)

- Make a cognate set alias

- Register a "sticky" source, so that all subsequent entries are
  attributed to that source

- Include flag

TODO
====

- Sources table, plus links

TECHNICAL NOTES
===============

Joins
-----

To go backwards through ``ManyToMany`` and ``ForeignKey`` fields the attribute
name is generated by appending the lower case model name to _set.

Big joins across tables::

  In [2]: c = CognateSet.objects.get(id=1)

  In [12]: c.cognatejudgement_set.all()[0].lexeme.meaning
  Out[12]: <Meaning: AND>

Another trick uses the double-underscore syntax::

  Lexeme.objects.filter(meaning__gloss="blood")

Database trigger
----------------

http://docs.djangoproject.com/en/dev/topics/signals/#topics-signals

Django equivalent of a database trigger::

  from django.db.models import signals

  def update_bookmark_aggregate(sender, instance, **kwargs):
      bmark = instance.bookmark
      bmark.num_votes = bmark.votes.count()
      bmark.score = sum(bmark.votes.values_list('value', flat=True))
      bmark.save(force_update=True)
  signals.post_save.connect(update_bookmark_aggregate, sender=Vote)

From: http://www.eflorenzano.com/blog/post/database-triggers-arent-evil-and-they-actually-kin/

vim
---

When lots of tabs open::

  set guitablabel=%t

.. vim:ft=rst
