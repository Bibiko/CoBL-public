Complete
========

Major features
------------------------

0.1   Design
0.2   Basic (all basic data input features in place)
0.2.1 Development: focus on usability
0.2.2 Usable form on the basic program
0.2.3 Version in production (Julia adding data)
0.2.4 Integrating the authentication system
0.2.5 Integrating the reversion system
0.3   -> when editing buttons on the template have been wrapped with permission
      checks

0.4   -> when the revert/undo button works well
      -> lexeme_history view

TODO
====

Major features
--------------

* Authentication -- DONE
* Reversion -- DONE
* Kinship system -- DONE
* Registration -- PARTIALLY DONE
* Comments
* Tagging/issue tracking system (maybe integrated with comment system, but
  probably not)

Minor features
--------------

* Backup system (crude version complete)
* Nexus output (basic version complete)
* CSV output (wait until there's a call for it)
* Editing membership of named lists

Refactoring
-----------

Concrete

* stacks of ``elif``

  change to::

    actions = {"action1":action1,
              "action2":action2}
    actions["action1"](request, **kwargs)

* boilerplate code::

    if request.method == "POST":
        <handle repeat visit>
    else:
        <handle first visit>

  Maybe set up something like::

    def new_request(request):
        return request.method != POST

  Then do::

    if new_request(request):
        <handle first visit>
    else:
        <handle repeat visit>

* use named urls throughout?

General 

* DNRY violations:

  - cancel button handling
  - fixing type of integer url elements

* functions are too long

* is it possible to wrap button functions in an html snippet

.. vim:ft=rst
