TODO
====

- remove the split/duplicate button (but leave it accessible from the url, like
  delete)

- rather than jumping to anchor text (e.g. when selecting add cognate class "+"
  button on the meaning list page), give the target row a "selected" class, and
  change the background colour in the CSS

- use session dictionaries to store "return to" and "#lexeme_XX" anchors
  information (since this doesn't mess with the explicit, replicable) url
  scheme.

- rewrite templates so the database can handle startup from nothing (e.g.
  initially, only offer "create language", "create meaning" pages) -- then zap
  the fixtures (which are annoying when you syncdb or migrate and forget to
  suppress them) **DONE?**

- Describe grammar of urls::

    /language/...(/wordlist/...)/ # list of words in a language *
    /language/.../                # default: all words in language *
    /language/.../domain/.../     # list of words in a language pertaining to
                                  # domain *
    /languages/.../               # names lists *
    /meaning/.../                 # list of all words with a meaning *
    /meaning/...(/languages/...)/ # list of words with a meaning (in language
                                  # list) *
    # lexemes in this view have identifiers, e.g.
    /meaning/animal/languages/aslian/#lexeme_6
    /meaning/.../delete/          # *
    /meanings/                    # alias for /wordlist/all/ *
    /wordlist/Swadesh100/         # a named list of meanings *
    /meanings/add-new/            # (this is why we need both meanings and wordlist) *
    /wordlists/                   # list defined wordlists *
    /domain/.../                  # relation names in a domain *

  **DONE**
  
  Reserved names for sets 'all' (for languages, meanings), 'none' (for
  meanings, domains)

  TODO: work on a set of explicit principles for url element order

  Urls consist of a sequence of  FUNCTION-ARGUMENT, VERB-OBJECT,
  CLASSIFIER-NOUN elements

  Adding lexemes, with different amounts of prespecified info::

    /language/.../lexeme/add/
    /meaning/.../lexeme/add/
    /language/.../meaning/.../lexeme/add/ # return to language
    /meaning/.../language/.../lexeme/add/ # return to meaning
    /lexeme/add/

  What is this for?::

    /meaning/GLOSS/LEXEME_ID/#lexeme_ID

  (it's used as a target for 'add cognate'). It should be::

    /lexeme/.../add-cognate/

  **TODO**

- lexeme actions. Most of these could be handled on separate pages with
  separate view logic rather than on a monster combined page::

    /lexeme/.../add-citation                        "add-lexeme-citation"
    /lexeme/.../add-cognate                         "link-cognate"
        => /lexeme/.../cognate/.../link
    /lexeme/.../add-cognate-citation/COGNATE_ID     "add-cognate-citation"
        => /lexeme/.../cognate/.../citation/
    /lexeme/.../add-new-citation # DELETE (not different from add-citation)
                                                    "add-new-lexeme-citation"
    /lexeme/.../add-new-cognate # previously unattested cognate set
                                                    "link-new-cognate"
    /lexeme/.../delete                              "delete-lexeme"
    /lexeme/.../delink-citation/CITATION_ID
        => /lexeme/.../citation/.../delink/         "delink-lexeme-citation'
    /lexeme/.../delink-cognate/COGNATE_ID
        => /lexeme/.../cognate/.../delink/          "delink-cognate"
    /lexeme/.../delink-cognate-citation/COGCITE_ID  "delink-cognate-citation"
        => /lexeme/.../cognate/.../citation/.../delink/
    /lexeme/.../edit                                "edit-lexeme"
    /lexeme/.../edit-citation/CITATION_ID
        => /lexeme/.../citation/.../edit/           "edit-lexeme-citation"
    /lexeme/.../edit-cognate-citation/COGCITE_ID    "edit-cognate-citation"
        => /lexeme/.../cognate/.../citation/.../edit/

- refactor base templates:

  These just need to take object, title_text, header_text arguments. This
  should then be easy to convert to class based views.

  * list_object
  * view_object
  * edit_object 
  * cite_object
  * delete_object
  * link_object
  * delink_object
  * change_and_reorder_from list (for language lists, meaning lists, etc)

  This is crying out for class-based views...

- Implement GenericCitation **DEFER**

  * Get the class working
  * Hook it up to Extensional Semantics objects and get it working on import of
    Aslian data
  * Copy all IE citations to new model
  * Hook up GenericCitation to lexicon models and templates
  * Drop old XxxCitation tables

  **This causes problems**

for Version 0.3
---------------

- Admin-Auth pages

  * Administrator:

    - add user
    - change user details

  * User

    - view own profile (incl. permissions)
    - view other user's profile (incl. statistics)
    - change password

  * Dashboard thing for users to set prefs, look at their contribution stats
    und zo weiter

- Implement permissions/permission groups on all editing actions

- change password view

- report permissions/group membership in profile

- Check that the same alias isn't used twice for different cognates, same
  meaning (e.g. in the 'breathe/life' and 'animal' sets). 
  
  Maybe: dynamically check that the list of aliases corresponds uniquely to a
  list of cognate sets, and apply a new alias to one of the forms (would have
  to check against the aliases used by the other meanings corresponding to the
  form as well).

- Need a many to many table linking cognate sets to sources: in lots of cases
  we have general information about the reconstructed form

- The Language.description field in (the sidebar of?) the /language/ view
  **DONE**

- Add/edit meaning pages; Allow e.g. addition of canonical context information 

- check all ModelForm edit functions that the instance is specified when these
  are intended to edit an existing object rather than create a new one (see
  view.py edit_language.py). **DONE?**

for Version 0.4
---------------

- Add comments field to all editing functions to add comment to version info.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

General
-------

- add a url ``/lexeme/XX/view-citation/YY/`` (and ``view-cognate-citation``,
  ``view-cognate``) equivalent to ``edit-citation`` etc., but just highlighting
  the relevant bit (for use in canonical_url)

- Dynamically generate a more interesting Acknowledgements page (feed it a
  LanguageList and a MeaningList argument, and output a list of contributors
  with a measure of their contributions, both who coded the data and the
  sources)

- Include all relevant citations in export functions.

- Use http://docs.djangoproject.com/en/dev/howto/custom-management-commands/ to
  make database-specific management functions (e.g. add users, change user
  permissions, change superuser password, etc)

- Recent changes is broken in the case that a lexeme is deleted (at least until
  it goes off the bottom of the screen) -- I think this is to do with the 'link
  to current object'

Development
-----------

- Make a developer site: bitbucket.org seems the most suitable.

- Do there need to be any import functions?
